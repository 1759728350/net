
sql基础操作


查慢sql,[sql慢查询](https://blog.csdn.net/qq_40991313/article/details/130355955?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171274789416800178569303%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=171274789416800178569303&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-130355955-null-null.nonecase&utm_term=mysql&spm=1018.2226.3001.4450)
索引优化
表设计优化
sql语句优化
[详细](https://blog.csdn.net/qq_40991313/article/details/131059110?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171274700316800227481843%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=171274700316800227481843&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-131059110-null-null.142^v100^pc_search_result_base3&utm_term=mysql%E8%B0%83%E4%BC%98&spm=1018.2226.3001.4187)

sql其他知识:
sql集群主从结构
[oracle和mysql区别](https://blog.csdn.net/qq_40991313/article/details/132077467)



### 表设计
#### 表字段数据类型
1. **整数类型**：
   - **TINYINT**：存储范围为-128到127或0到255的整数。
   - **SMALLINT**：存储范围为-32768到32767或0到65535的整数。
   - **INT**（INTEGER）：存储范围为-2147483648到2147483647或0到4294967295的整数。
   - **BIGINT**：存储范围为-9223372036854775808到9223372036854775807或0到18446744073709551615的整数。

2. **浮点数类型**：
   - **FLOAT**：存储单精度浮点数。
   - **DOUBLE**：存储双精度浮点数。
   - **DECIMAL**（DEC）：存储精确小数，用于财务计算等需要精确值的场景。

3. **字符串类型**：
   - **CHAR**：固定长度字符串，最大长度为255个字符。
   - **VARCHAR**：可变长度字符串，最大长度取决于定义的长度。
   - **TEXT**：用于存储大文本数据，如文章内容、日志等。

4. **日期和时间类型**：
   - **DATE**：存储日期，格式为'YYYY-MM-DD'。
   - **TIME**：存储时间，格式为'HH:MM:SS'。
   - **DATETIME**：存储日期和时间，格式为'YYYY-MM-DD HH:MM:SS'。
   - **TIMESTAMP**：存储时间戳，包括日期和时间。存储秒数

5. **布尔类型**：
   - **BOOL**（BOOLEAN）：存储布尔值，通常为TRUE或FALSE。

6. **二进制类型**：
   - **BLOB**：用于存储二进制数据，如图片、视频、文件等。

7. **枚举类型**：
   - **ENUM**：定义枚举值列表，只能存储列表中的某个值。

#### 字段数据类型优化
 整数类型：
>考虑好数值范围，前期可以使用int保证稳定性。非负数类型要用UNSIGNED；同样字节数，存储的数值范围更大。主键一般使用bigint,布尔类型tinint

能整数就不要用文本类型：
>跟文本类型数据相比，大整数往往占用更少的存储空间。

避免使用TEXT、BLOB数据类：
>这两个大数据类型，排序时不能使用临时内存表，只能使用磁盘临时表，效率很差，建议别用，或分表到单独扩展表里。LongBlob类型能存储4G文件；

使用TIMESTAMP存储时间：
>TIMESTAMP使用4字节，DATETIME使用8个字节，同时TIMESTAMP具有自动赋值以及自动更新的特性。 缺点是只能存到2038年，MySQL5.6.4版本可以参数配置，自动修改它为BIGINT类型。

用DECIMAL存浮点数：
>Decimal类型为精准浮点数，在计算时不会丢失精度，尤其是财务相关的金融类数据。占用空间由定义的宽度决定，每4个字节可以存储9位数字，并且小数点要占用一个字节。可用于存储比bigint更大的整型数据。 

#### 表优化
##### 冷热数据分表
- 将订单数据根据访问频率和时效性分为热数据（经常访问的数据）和冷数据（不经常访问的数据）。
- 将热数据存储在高性能的存储介质（如SSD固态硬盘）上，以提供快速访问和查询。
- 将冷数据存储在低成本、高容量的存储介质（如HDD普通机械硬盘）上，以节省成本和存储空间。
- 可以通过数据迁移和归档策略，定期将不再频繁访问的数据从热表中迁移到冷表中。

##### 根据业务状态分表
- 根据订单状态将订单数据分散到不同的表中，例如已完成订单、待支付订单、已取消订单等。
- 每个表可以根据具体的业务需求设计不同的索引和数据存储结构，以提高查询效率。
- 可以根据业务的读写频率和数据增长情况来动态调整表的数量和切分规则。

### 存储引擎

对比

|      | InnoDB                           | MyISAM                       |
| ---- | -------------------------------- | ---------------------------- |
| 特点   | 支持外键和事务                          | 不支持外键和事务                     |
| 锁    | 行锁，操作时只锁某一行，不对其它行有影响， 适合高并发的操作   | 表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作 |
| 缓存   | 缓存索引和数据,对内存要求较高, 数据库对内存的开销是比较敏感的 | 只缓存索引,不缓存真实数据                |
| 关注点  | 并发写, 事务, 消耗更大资源                  | 节省资源, 业务简单, 查询快              |
| 默认使用 | mysql5.5版本及其之后                   | 5.5版本之前                      |




### 索引
#### 设计和创建索引

##### 索引建立原则？
*  唯一特性的字段，适合创建索引；

* 为常作为查询条件的字段建立索引

* 为经常需要排序、分组和联合操作以及查询的列建立索引；
经常需要 ORDER BY、GROUP BY、DISTINCT 等操作的字段，排序操作会浪费很多时间。如果为其建立索引，可以有效地避免排序操作。

* 频繁更新的表，不要创建过多索引

* 限制索引的数目；
每个索引都需要占⽤用磁盘空间，索引越多，需要的磁盘空间就越大，修改表时，对索引的重构和更新很麻烦。

* 小表不建议索引（如数量级在百万以内）；
由于数据较小，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果。

* 尽量使用数据量少的索引；
如果索引的值很长，那么查询的速度会受到影响。此时尽量使用前缀索引。比如很长的varchar字段，适合根据区分度和长度创建前缀索引；

*  多个字段都要创建索引时，联合索引优于单值索引；

##### 创建索引
在 MySQL 中，可以使用 `CREATE INDEX` 语句来创建索引。具体代码如下：

1. **创建单列索引**：
```sql
CREATE INDEX index_name ON table_name (column_name);
```
其中，`index_name` 是索引的名称，`table_name` 是表名，`column_name` 是要在其上创建索引的列名。

例如，为名为 `students` 的表的 `class` 列创建索引的示例代码：
```sql
CREATE INDEX idx_class ON students (class);
```

2. **创建组合索引**：
```sql
CREATE INDEX index_name ON table_name (column_name1, column_name2, ...);
```
可以为多个列一起创建组合索引。

例如，为名为 `students` 的表的 `class` 和 `age` 列创建组合索引的示例代码：
```sql
CREATE INDEX idx_class_age ON students (class, age);
```


##### 查看sql使用的索引
好的，让我们以一个简单的例子来演示如何通过 Explain Plan 来查看 SQL 查询是否使用了索引。

假设有以下表 `students`：
```
CREATE TABLE students (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    age INT,
    class VARCHAR(20)
);
```

我们要查询年龄在 20 到 30 岁之间，且班级为 'A' 的学生信息，并查看该查询是否使用了索引。

SQL 查询语句如下：
```sql
EXPLAIN SELECT * FROM students WHERE age BETWEEN 20 AND 30 AND class = 'A';
```

执行上述 SQL 查询，并查看 Explain Plan 的输出结果，主要关注 `type` 和 `key` 列。

输出结果
```table
+----+-----------+----------+------------+------+---------------+------+---------+------+-----
| id |select_type|  table   | type | possible_keys |  key   | rows | filtered |   Extra     |
+----+-----------+----------+------------+------+---------------+------+---------+------+-----
| 1  | SIMPLE    | students | ref  | age,class     |  class |  2   | 100.00   | Using where |
+----+-----------+----------+------------+------+---------------+------+---------+------+----
```

在这个例子中，我们可以看到：
- `type` 为 `ref`，表示使用了索引进行范围查找。
- `possible_keys` 列显示可能使用的索引，这里是 `age,class`。
- `key` 列显示实际使用的索引，这里是 `class`。
- `Extra` 列中的 `Using where` 表示除了索引外还需进一步使用 WHERE 子句进行条件过滤。

因此，根据 Explain Plan 的输出结果，我们可以判断该 SQL 查询在 `class` 列上使用了索引来进行条件筛选。

注意:<font color=#F09B59 style=" font-weight:bold;">没有在class上建立索引,explain是查不到索引的,所以需要提前建立</font>

#### 索引失效

1. **未使用索引列进行查询**：当查询语句中没有使用到创建的索引列，而是对其他列进行查询，索引将不起作用，导致索引失效。例如，如果在一个表上创建了"user_id"的索引，但查询语句中并未包含"user_id"列作为条件，那么索引将不会被使用。

2. **列类型被改变了或者连表时类型被强转**：如果查询语句中对索引列进行了函数操作或类型转换，索引将无法被有效使用，从而导致索引失效。例如，如果在一个整型列上创建了索引，但查询时使用了该列的字符串形式进行查询，那么索引将不会生效。

3. **建索引的列数据区分度小**：当索引列的数据分布极不均匀时，索引可能会失效。如果某个索引列上的大部分值相同，而少数值占据很大比例，索引可能无法提供足够的过滤效果，导致失效。

4. **表中数据量较小**：当表中数据量较小时，数据库系统可能选择全表扫描而不使用索引，因为索引的优化效果对小数据集不太显著，这种情况下索引可能会失效。

5. **建立索引的列经常更新**：对频繁更新的列创建索引可能会导致索引失效，因为每次更新都需要维护索引结构，增加了额外的开销。特别是在高并发环境下，频繁更新的列可能使索引失效。

6. **未按照组合索引顺序查询**：如果在某个表的多列上创建了索引，但查询时未按照索引顺序使用所有列，索引可能无法被完全利用，导致失效。

对于以上情况，DBA可以通过分析查询执行计划、监控索引的使用情况，以及优化查询语句和索引设计等方式来避免索引失效，提高数据库查询性能。

#### 索引优化
##### 实际生产环境中的索引优化案例
假设有一个电子商务网站，数据库中有一个名为"orders"的表，用于存储订单信息，包括订单号（order_id）、用户ID（user_id）、订单日期（order_date）、订单状态（status）等字段。现在经常需要查询某个用户最近的订单信息，可以根据用户ID和订单日期进行查询。但是由于订单数据量巨大，查询速度较慢。

针对这个情况，可以进行索引优化来提高查询效率。以下是一种优化方案：

1. 在"user_id"和"order_date"列上创建复合索引：由于查询通常涉及用户ID和订单日期两个条件，可以在这两列上创建一个复合索引，以加快根据用户ID和订单日期进行查询的速度。复合索引可以帮助数据库系统更快地定位符合条件的数据行。

2. 考虑使用覆盖索引：如果查询只需要返回"user_id"和"order_date"这两列的数据，可以考虑创建覆盖索引。覆盖索引是指索引中包含了查询需要的所有列，避免了回表操作，进一步提高查询性能。

3. 定期优化索引：定期对索引进行优化和维护是很重要的。可以通过分析查询执行计划、监控索引的使用情况和碎片情况，及时调整索引设计，保持索引的高效性。


##### 索引覆盖所有结果
一个组合索引正好是你要查询的所有数据, 这时就不需要再去根据索引去找整个行了,
所以尽量用使用组合索引把要查询的结果全给覆盖了..

索引->索引指向的值->索引指向的整个行


##### 取字符串前缀作索引
mysql默认使用整个字符串作为索引,如果不给长度的话

使用前缀索引，定义好长度，**就可以做到既节省空间，又不用额外增加太多的查询成本。，区分度越高越好**。因为区分度越高，意味着重复的键值越少。
```sql
mysql> alter table teacher add index index1(email);
#或
mysql> alter table teacher add index index2(email(6)); ##取邮箱前六位,取最不一样的一段作为索引
```


### 事务
#### 隔离级别
在关系型数据库中，常见的事务隔离级别包括以下四种：

1. 读未提交（Read Uncommitted）：最低级别的隔离级别，允许一个事务读取另一个事务尚未提交的数据。这可能导致脏读（Dirty Read）等问题。

2. 读已提交（Read Committed）：要求一个事务只能读取已提交的数据，避免了脏读问题。不过，存在不可重复读和幻读。

3. 可重复读（Repeatable Read）：要求一个事务在执行过程中看到的数据始终保持一致，即使其他事务对数据做出修改。这可以避免不可重复读问题，但仍可能出现幻读问题。

4. 串行化（Serializable）：提供最高的隔离级别，通过强制事务串行执行来避免脏读、不可重复读和幻读。不过，由于串行化会导致性能损失，因此一般很少使用。

每种隔离级别都有其优缺点，开发人员需要根据具体业务场景和需求选择合适的隔离级别。低隔离级别可以提高并发性能，但可能导致数据不一致问题；而高隔离级别可以确保数据一致性，但可能会降低并发性能。
    

<font color=#99CCFF style=" font-weight:bold;">Mysql默认的事务隔离级别是可重复读</font>


#### 事务并发产生的问题
产生脏读，不可重复读, 幻读

- <font color=#99CCFF style=" font-weight:bold;">事务A在执行过程中读取到事务B执行时未提交的数据,这就是脏读</font>
    
- 在一次事务，两个相同的查询，前后查的数据不一样，这就是不可重复读。
    
- 事务A查询一个范围的数据，另一个并发事务B往这个范围中插入/删除了数据，并静悄悄地提交，然后事务A再次查询相同的范围，两次读取得到的结果集不一样了，这就是幻读。

<font color=#99CCFF style=" font-weight:bold;">inndb因为是可重复读的隔离级别,所以能解决脏读和不可重复读,但解决不了幻读</font>

#### ACID特性及其实现原理：

- 原子性：语句要么全执行，要么全不执行，是事务最核心的特性，事务本身就是以原子性来定义的；实现主要基于undo log
- 持久性：保证事务提交后不会因为宕机等原因导致数据丢失；实现主要基于redo log
- 隔离性：保证事务执行尽可能不受其他事务影响；InnoDB默认的隔离级别是RR，RR的实现主要基于锁机制（包含next-key lock）、MVCC（包括数据的隐藏列、基于undo log的版本链、ReadView）
- 一致性：事务追求的最终目标，一致性的实现既需要数据库层面的保障，也需要应用层面的保障, 多个事务相互协同,无论成功失败,结果都是符合预期的, 比如a事务向b事务转账, 无论成功失败与否两个账户总金额肯定不对变多

### 锁
在InnoDB存储引擎中，默认情况下，每句SQL语句会自动使用<font color=#99CCFF style=" font-weight:bold;">行级锁</font>（Row-Level Locking）。这意味着每个SQL语句在执行时会锁定所涉及的行，而不是锁定整个表或表中的其他行，以提高并发性能。

如果没有明确指定锁类型，InnoDB存储引擎会根据具体的操作自动选择合适的锁级别，通常会使用行级锁。这样可以确保在并发环境下，多个事务可以同时访问同一张表的不同行而不会相互阻塞，提高了数据库的并发性能。

需要注意的是，尽管InnoDB默认使用行级锁，但在实际应用中，根据具体业务需求和并发访问情况，有时候可能需要手动指定不同的锁类型，以保证数据访问的正确性和一致性。


##### 行级锁和表锁
表锁（Table-level Locks）和行级锁（Row-level Locks）是MySQL中两种不同粒度的锁，用于控制并发访问和确保数据一致性。

1. 表锁（Table-level Locks）：表锁是锁定整个表的锁，当一个事务获取了对表的表锁后，其他事务无法同时对这个表进行修改操作，即使它们要修改的是表中的不同记录。表锁的粒度比较粗，会限制其他事务对整个表的访问。

2. 行级锁（Row-level Locks）：行级锁是针对数据表中的每一行记录进行锁定，当一个事务获取了对某一行记录的行级锁后，其他事务还可以同时对表中的其他行进行读取或修改操作。行级锁的粒度更细，能够更好地支持并发访问。

<font color=#99CCFF style=" font-weight:bold;">在InnoDB引擎中，默认情况下使用的是行级锁来实现并发控制</font>。行级锁可以最大程度地提高并发性能，减少锁冲突和阻塞情况。而表锁通常在特定场景下使用，如需要快速锁定整个表进行操作时，或者为了避免某些特定的并发问题而需要手动选择表锁。

总的来说，行级锁提供了更细粒度的并发控制，更适合常见的并发访问场景；而表锁虽然简单直接，但在大多数情况下不推荐使用，因为会降低数据库的并发性能和响应速度。

##### 共享锁和排他锁
行级锁和表级锁是用来描述锁粒度的,
共享锁是传统的读锁,
排他锁就是传统的写锁
这两个锁是用来描述锁的并发隔离特点的

##### 死锁案例
**案例一 两个事务同时对一行进行增删改,并加排它锁**

用户A执行：
```sql
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE user_id = 123;
UPDATE products SET stock = stock + 1 WHERE product_id = 456;
COMMIT;
```

用户B执行：
```sql
BEGIN;
UPDATE products SET stock = stock - 1 WHERE product_id = 456;
UPDATE accounts SET balance = balance + 100 WHERE user_id = 123;
COMMIT;
```

在这个场景中，用户A先锁定了products表中product_id为456的行，然后尝试更新accounts表；而用户B则先锁定了accounts表中user_id为123的行，然后尝试更新products表。由于两个事务的操作顺序不一致，很可能会导致死锁的发生。

<font color=#99CCFF style=" font-weight:bold;">行级锁相互锁定了,导致死锁</font>

**案列2 对select加额外升级锁后,两事务对同一行加锁**

用户A执行：
```sql
BEGIN;
SELECT * FROM orders WHERE user_id = 123 FOR UPDATE; -- 获取订单信息并加排他锁
UPDATE products SET stock = stock - 1 WHERE product_id = 456;
COMMIT;
```

用户B执行：
```sql
BEGIN;
SELECT * FROM products WHERE product_id = 456 FOR UPDATE; -- 获取产品信息并加排他锁
UPDATE orders SET status = 'shipped' WHERE order_id = 789;
COMMIT;
```

在这个例子中，用户A先获取了orders表中user_id为123的订单信息并加排他锁，然后尝试更新products表；而用户B则先获取了products表中product_id为456的产品信息并加排他锁，然后尝试更新orders表。这种交叉持有锁和操作不一致的情况容易导致死锁的发生。




为避免这种情况下的死锁，可以考虑以下解决方法：

1. 统一事务的操作顺序，确保所有事务都按照相同的顺序操作数据库表；
2. 减少事务中持有的锁数量和时间，尽量缩短事务的执行时间；
3. 在应用程序中使用尽量少的SQL语句来完成需要的操作；
4. 使用合适的索引和查询语句，减少数据访问的范围，降低发生死锁的概率；
5. 监控数据库系统，及时发现死锁并进行处理。


#### 悲观锁
悲观锁就是行锁和表锁
悲观锁思想就是，当前线程要进来修改数据时，别的线程都得拒之门外~
主要就是看存储引擎,innodb的悲观锁默认采用行级锁

```sql
比如，可以使用select…for update ~

select * from User where name=‘jay’ for update
```

#### 乐观锁
在MySQL中，乐观锁是一种基于数据版本控制的并发控制机制。乐观锁假设数据在大多数情况下不会发生冲突，因此允许事务在不加锁的情况下进行读取和修改操作，只在提交时检查数据是否被其他事务修改过。

乐观锁的实现通常通过以下方式：

1. **版本号（Versioning）**：每行数据都包含一个版本号字段，当事务读取数据时会把版本号一并读取出来。在更新数据时，事务会对比当前版本号和最初读取的版本号，如果一致则进行更新操作，如果不一致则认为数据已经被其他事务修改，需要进行回滚或重试操作。

2. **时间戳（Timestamp）**：类似版本号，每行数据包含一个时间戳字段，用于记录数据最后修改的时间。事务在写入数据时记录当前时间戳，并在提交时对比之前读取的时间戳，以确保数据未被修改。

乐观锁适用于<font color=#FFCCCC style=" font-weight:bold;">并发读多写少的场景</font>，可以提高系统的并发性能和吞吐量。但是在写入操作较频繁或数据冲突较多时，可能会导致更新操作失败，需要处理更新冲突的情况。

<font color=#99CCFF style=" font-weight:bold;">在MySQL中，乐观锁主要在java业务代码层面去实现, 比如springboot中的事务去实现</font>

**案例**

以下是一个简单的使用乐观锁的代码示例，假设我们有一个名为 `users` 的表，其中包含 `id` 和 `name` 字段，并且有一个版本号字段 `version` 来实现乐观锁：

```sql
CREATE TABLE users (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    version INT
);

INSERT INTO users (id, name, version) VALUES (1, 'Alice', 1);
```

在应用程序中，执行更新操作时可以通过比较版本号来实现乐观锁控制：

```python
import pymysql

# 连接数据库
connection = pymysql.connect(host='localhost', user='root', password='password', database='testdb', autocommit=False)
cursor = connection.cursor()

# 定义更新函数
def update_user_name(user_id, new_name):
    try:
        # 开启事务
        connection.begin()
        
        # 查询用户信息和版本号
        cursor.execute("SELECT name, version FROM users WHERE id = %s FOR UPDATE", (user_id,))
        result = cursor.fetchone()
        
        if result:
            current_name, current_version = result
            
            # 模拟业务逻辑中对数据进行修改
            updated_name = current_name + " " + new_name
            
            # 更新数据前再次检查版本号
            cursor.execute("UPDATE users SET name = %s, version = version + 1 WHERE id = %s AND version = %s", (updated_name, user_id, current_version))
            if cursor.rowcount == 0:
                # 版本号不匹配，说明数据已经被其他事务修改，回滚事务
                connection.rollback()
                print("Update failed due to concurrent modification")
            else:
                # 提交事务
                connection.commit()
                print("Update successful")
        else:
            print("User not found")
    
    except Exception as e:
        print("Error:", e)
        connection.rollback()

# 调用更新函数
update_user_name(1, "Smith")

# 关闭连接
cursor.close()
connection.close()
```

在这个示例中，`update_user_name` 函数通过比较版本号来实现乐观锁控制，确保在并发情况下数据的一致性。如果版本号匹配，则更新数据并提交事务；如果版本号不匹配，则认为数据已经被其他事务修改，进行回滚操作。这样就实现了一个简单的乐观锁机制。


### sql执行过程

1. 连接管理：MySQL通过连接池管理数据库连接，当有客户端发送SQL请求时，会从连接池中获取一个可用的连接。

2. 语句分析和优化：MySQL接收到SQL请求后，首先会对SQL语句进行语法分析和语义分析，生成执行计划。优化器会根据查询条件、索引等情况选择最优的执行方案。

3. 锁管理：在执行SQL语句时，MySQL会根据具体的操作和事务隔离级别自动添加适当的锁来保证数据的一致性。不同的锁级别会影响并发访问的方式和性能。

4. 执行SQL语句：MySQL会执行经过优化的SQL语句，并返回结果给客户端。在执行过程中，会根据需要读取数据页、执行计划中的操作等。

5. 事务管理：对于涉及事务的SQL请求，MySQL会根据事务的开始、提交、回滚等操作来确保事务的原子性、一致性、隔离性和持久性。

6. 结果返回：执行完SQL语句后，MySQL将结果返回给客户端，并释放相应的资源，如锁、连接等。

在处理并发的SQL请求时，MySQL会根据事务隔离级别、锁机制、执行计划优化等因素来保证多个同时进行的操作之间不会相互干扰，确保数据操作的正确性和一致性。通过合理设置参数、索引、优化SQL语句等手段，可以提高MySQL处理并发请求的性能和效率。

### 排查慢sql
开启慢查询日志,设置慢查询的阈值


[详细](https://blog.csdn.net/qq_40991313/article/details/131059110?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171274700316800227481843%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=171274700316800227481843&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-131059110-null-null.142^v100^pc_search_result_base3&utm_term=mysql%E8%B0%83%E4%BC%98&spm=1018.2226.3001.4187)
### sql优化

##### 连接查询优化
* 外连 接时优先给被驱动表连接字段加索引
外连接查询时，右表就是被驱动表，建议加索引。<font color=#FFCCCC style=" font-weight:bold;">因为左表是查所有数据,扫描整个表没必要建立索引，右表是按条件查询，所以右表的条件字段创建索引价值更高一点</font>。


* 内连接时选有索引的作被驱动表


* 两表连接字段 类型必须一致
两个表JOIN字段数据类型保持绝对一致。防止自动类型转换导致索引失效。

##### 子查询优化
多表连接代替子查询,能有效减少查询次数


##### count优化
最好用count(*)和count(1), 这两个优化器会选用最佳的索引


##### 尽量SELECT(明确字段)

建议明确字段，查询优化器解析“*”符号为所有列名耗费时间，并且“*”号无法使用覆盖索引。

##### 全表扫描时尽量用“LIMIT”

当全表扫描时，并且你知道结果集记录数量时，用limit限制，这样扫描足够数量后就停止，不再扫描完全表了。如果有索引，就无需用limit了。

##### 将长事务拆为多个小事务：

尽量多使用 COMMIT，用编程式事务而不是声明式事务，降低事务粒度。
提交事务可以释放的资源：回滚段上用于恢复数据的信息、锁、redo / undo log buffer 中的空间。

##### 先查再删改：
UPDATE、DELETE语句一定要有明确的WHERE条件。

##### 尽量UNION ALL而不是UNION：
UNION A LL不去重，速度更快。
union关键字是将两个查询结果合并在一起并去重, union all不去重速度更快
