### mysql字段数据类型
1. **整数类型**：
   - **TINYINT**：存储范围为-128到127或0到255的整数。
   - **SMALLINT**：存储范围为-32768到32767或0到65535的整数。
   - **INT**（INTEGER）：存储范围为-2147483648到2147483647或0到4294967295的整数。
   - **BIGINT**：存储范围为-9223372036854775808到9223372036854775807或0到18446744073709551615的整数。

2. **浮点数类型**：
   - **FLOAT**：存储单精度浮点数。
   - **DOUBLE**：存储双精度浮点数。
   - **DECIMAL**（DEC）：存储精确小数，用于财务计算等需要精确值的场景。

3. **字符串类型**：
   - **CHAR**：固定长度字符串，最大长度为255个字符。
   - **VARCHAR**：可变长度字符串，最大长度取决于定义的长度。
   - **TEXT**：用于存储大文本数据，如文章内容、日志等。

4. **日期和时间类型**：
   - **DATE**：存储日期，格式为'YYYY-MM-DD'。
   - **TIME**：存储时间，格式为'HH:MM:SS'。
   - **DATETIME**：存储日期和时间，格式为'YYYY-MM-DD HH:MM:SS'。
   - **TIMESTAMP**：存储时间戳，包括日期和时间。存储秒数

5. **布尔类型**：
   - **BOOL**（BOOLEAN）：存储布尔值，通常为TRUE或FALSE。

6. **二进制类型**：
   - **BLOB**：用于存储二进制数据，如图片、视频、文件等。

7. **枚举类型**：
   - **ENUM**：定义枚举值列表，只能存储列表中的某个值。

## 索引

##### 索引建立原则？
* 选择唯一性索引；
唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录。

* 为常作为查询条件的字段建立索引

* 为经常需要排序、分组和联合操作的字段建立索引；
经常需要 ORDER BY、GROUP BY、DISTINCT 等操作的字段，排序操作会浪费很多时间。如果为其建立索引，可以有效地避免排序操作。

* 限制索引的数目；
每个索引都需要占⽤用磁盘空间，索引越多，需要的磁盘空间就越大，修改表时，对索引的重构和更新很麻烦。

* 小表不建议索引（如数量级在百万以内）；
由于数据较小，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果。

* 尽量使用数据量少的索引；
如果索引的值很长，那么查询的速度会受到影响。此时尽量使用前缀索引。

* 删除不再使用或者很少使用的索引。
##### 索引失效

索引在某些情况下可能会失效，导致数据库查询性能下降。以下是一些常见情况导致索引失效的情况：

1. **未使用索引列进行查询**：当查询语句中没有使用到创建的索引列，而是对其他列进行查询，索引将不起作用，导致索引失效。例如，如果在一个表上创建了"user_id"的索引，但查询语句中并未包含"user_id"列作为条件，那么索引将不会被使用。

2. **列类型不匹配**：如果查询语句中对索引列进行了函数操作或类型转换，索引将无法被有效使用，从而导致索引失效。例如，如果在一个整型列上创建了索引，但查询时使用了该列的字符串形式进行查询，那么索引将不会生效。

3. **数据分布不均匀**：当索引列的数据分布极不均匀时，索引可能会失效。如果某个索引列上的大部分值相同，而少数值占据很大比例，索引可能无法提供足够的过滤效果，导致失效。

4. **表中数据量较小**：当表中数据量较小时，数据库系统可能选择全表扫描而不使用索引，因为索引的优化效果对小数据集不太显著，这种情况下索引可能会失效。

5. **频繁更新的列**：对频繁更新的列创建索引可能会导致索引失效，因为每次更新都需要维护索引结构，增加了额外的开销。特别是在高并发环境下，频繁更新的列可能使索引失效。

6. **索引未统一前缀**：如果在某个表的多列上创建了索引，但查询时未按照索引顺序使用所有列，索引可能无法被完全利用，导致失效。

对于以上情况，DBA可以通过分析查询执行计划、监控索引的使用情况，以及优化查询语句和索引设计等方式来避免索引失效，提高数据库查询性能。

##### 实际生产环境中的索引优化案例
假设有一个电子商务网站，数据库中有一个名为"orders"的表，用于存储订单信息，包括订单号（order_id）、用户ID（user_id）、订单日期（order_date）、订单状态（status）等字段。现在经常需要查询某个用户最近的订单信息，可以根据用户ID和订单日期进行查询。但是由于订单数据量巨大，查询速度较慢。

针对这个情况，可以进行索引优化来提高查询效率。以下是一种优化方案：

1. 在"user_id"和"order_date"列上创建复合索引：由于查询通常涉及用户ID和订单日期两个条件，可以在这两列上创建一个复合索引，以加快根据用户ID和订单日期进行查询的速度。复合索引可以帮助数据库系统更快地定位符合条件的数据行。

2. 考虑使用覆盖索引：如果查询只需要返回"user_id"和"order_date"这两列的数据，可以考虑创建覆盖索引。覆盖索引是指索引中包含了查询需要的所有列，避免了回表操作，进一步提高查询性能。

3. 定期优化索引：定期对索引进行优化和维护是很重要的。可以通过分析查询执行计划、监控索引的使用情况和碎片情况，及时调整索引设计，保持索引的高效性。

