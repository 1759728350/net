
sql基础操作

sql调优:
查慢sql,[sql慢查询](https://blog.csdn.net/qq_40991313/article/details/130355955?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171274789416800178569303%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=171274789416800178569303&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-130355955-null-null.nonecase&utm_term=mysql&spm=1018.2226.3001.4450)
索引优化
表设计优化
sql语句优化
[详细](https://blog.csdn.net/qq_40991313/article/details/131059110?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171274700316800227481843%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=171274700316800227481843&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-131059110-null-null.142^v100^pc_search_result_base3&utm_term=mysql%E8%B0%83%E4%BC%98&spm=1018.2226.3001.4187)

sql其他知识:
sql集群主从结构
[oracle和mysql区别](https://blog.csdn.net/qq_40991313/article/details/132077467)


### 表字段数据类型
1. **整数类型**：
   - **TINYINT**：存储范围为-128到127或0到255的整数。
   - **SMALLINT**：存储范围为-32768到32767或0到65535的整数。
   - **INT**（INTEGER）：存储范围为-2147483648到2147483647或0到4294967295的整数。
   - **BIGINT**：存储范围为-9223372036854775808到9223372036854775807或0到18446744073709551615的整数。

2. **浮点数类型**：
   - **FLOAT**：存储单精度浮点数。
   - **DOUBLE**：存储双精度浮点数。
   - **DECIMAL**（DEC）：存储精确小数，用于财务计算等需要精确值的场景。

3. **字符串类型**：
   - **CHAR**：固定长度字符串，最大长度为255个字符。
   - **VARCHAR**：可变长度字符串，最大长度取决于定义的长度。
   - **TEXT**：用于存储大文本数据，如文章内容、日志等。

4. **日期和时间类型**：
   - **DATE**：存储日期，格式为'YYYY-MM-DD'。
   - **TIME**：存储时间，格式为'HH:MM:SS'。
   - **DATETIME**：存储日期和时间，格式为'YYYY-MM-DD HH:MM:SS'。
   - **TIMESTAMP**：存储时间戳，包括日期和时间。存储秒数

5. **布尔类型**：
   - **BOOL**（BOOLEAN）：存储布尔值，通常为TRUE或FALSE。

6. **二进制类型**：
   - **BLOB**：用于存储二进制数据，如图片、视频、文件等。

7. **枚举类型**：
   - **ENUM**：定义枚举值列表，只能存储列表中的某个值。


### 存储引擎

对比

|      | InnoDB                           | MyISAM                       |
| ---- | -------------------------------- | ---------------------------- |
| 特点   | 支持外键和事务                          | 不支持外键和事务                     |
| 锁    | 行锁，操作时只锁某一行，不对其它行有影响， 适合高并发的操作   | 表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作 |
| 缓存   | 缓存索引和数据,对内存要求较高, 数据库对内存的开销是比较敏感的 | 只缓存索引,不缓存真实数据                |
| 关注点  | 并发写, 事务, 消耗更大资源                  | 节省资源, 业务简单, 查询快              |
| 默认使用 | mysql5.5版本及其之后                   | 5.5版本之前                      |




### 索引

##### 索引建立原则？
* 选择唯一值作为索引；
唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录。

* 为常作为查询条件的字段建立索引

* 为经常需要排序、分组和联合操作的字段建立索引；
经常需要 ORDER BY、GROUP BY、DISTINCT 等操作的字段，排序操作会浪费很多时间。如果为其建立索引，可以有效地避免排序操作。

* 限制索引的数目；
每个索引都需要占⽤用磁盘空间，索引越多，需要的磁盘空间就越大，修改表时，对索引的重构和更新很麻烦。

* 小表不建议索引（如数量级在百万以内）；
由于数据较小，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果。

* 尽量使用数据量少的索引；
如果索引的值很长，那么查询的速度会受到影响。此时尽量使用前缀索引。

* 删除不再使用或者很少使用的索引。
##### 索引失效

索引在某些情况下可能会失效，导致数据库查询性能下降。以下是一些常见情况导致索引失效的情况：

1. **未使用索引列进行查询**：当查询语句中没有使用到创建的索引列，而是对其他列进行查询，索引将不起作用，导致索引失效。例如，如果在一个表上创建了"user_id"的索引，但查询语句中并未包含"user_id"列作为条件，那么索引将不会被使用。

2. **列类型不匹配**：如果查询语句中对索引列进行了函数操作或类型转换，索引将无法被有效使用，从而导致索引失效。例如，如果在一个整型列上创建了索引，但查询时使用了该列的字符串形式进行查询，那么索引将不会生效。

3. **数据分布不均匀**：当索引列的数据分布极不均匀时，索引可能会失效。如果某个索引列上的大部分值相同，而少数值占据很大比例，索引可能无法提供足够的过滤效果，导致失效。

4. **表中数据量较小**：当表中数据量较小时，数据库系统可能选择全表扫描而不使用索引，因为索引的优化效果对小数据集不太显著，这种情况下索引可能会失效。

5. **频繁更新的列**：对频繁更新的列创建索引可能会导致索引失效，因为每次更新都需要维护索引结构，增加了额外的开销。特别是在高并发环境下，频繁更新的列可能使索引失效。

6. **索引未统一前缀**：如果在某个表的多列上创建了索引，但查询时未按照索引顺序使用所有列，索引可能无法被完全利用，导致失效。

对于以上情况，DBA可以通过分析查询执行计划、监控索引的使用情况，以及优化查询语句和索引设计等方式来避免索引失效，提高数据库查询性能。

##### 实际生产环境中的索引优化案例
假设有一个电子商务网站，数据库中有一个名为"orders"的表，用于存储订单信息，包括订单号（order_id）、用户ID（user_id）、订单日期（order_date）、订单状态（status）等字段。现在经常需要查询某个用户最近的订单信息，可以根据用户ID和订单日期进行查询。但是由于订单数据量巨大，查询速度较慢。

针对这个情况，可以进行索引优化来提高查询效率。以下是一种优化方案：

1. 在"user_id"和"order_date"列上创建复合索引：由于查询通常涉及用户ID和订单日期两个条件，可以在这两列上创建一个复合索引，以加快根据用户ID和订单日期进行查询的速度。复合索引可以帮助数据库系统更快地定位符合条件的数据行。

2. 考虑使用覆盖索引：如果查询只需要返回"user_id"和"order_date"这两列的数据，可以考虑创建覆盖索引。覆盖索引是指索引中包含了查询需要的所有列，避免了回表操作，进一步提高查询性能。

3. 定期优化索引：定期对索引进行优化和维护是很重要的。可以通过分析查询执行计划、监控索引的使用情况和碎片情况，及时调整索引设计，保持索引的高效性。

### 锁
在InnoDB存储引擎中，默认情况下，每句SQL语句会自动使用<font color=#99CCFF style=" font-weight:bold;">行级锁</font>（Row-Level Locking）。这意味着每个SQL语句在执行时会锁定所涉及的行，而不是锁定整个表或表中的其他行，以提高并发性能。

如果没有明确指定锁类型，InnoDB存储引擎会根据具体的操作自动选择合适的锁级别，通常会使用行级锁。这样可以确保在并发环境下，多个事务可以同时访问同一张表的不同行而不会相互阻塞，提高了数据库的并发性能。

需要注意的是，尽管InnoDB默认使用行级锁，但在实际应用中，根据具体业务需求和并发访问情况，有时候可能需要手动指定不同的锁类型，以保证数据访问的正确性和一致性。


##### 行级锁
表锁（Table-level Locks）和行级锁（Row-level Locks）是MySQL中两种不同粒度的锁，用于控制并发访问和确保数据一致性。

1. 表锁（Table-level Locks）：表锁是锁定整个表的锁，当一个事务获取了对表的表锁后，其他事务无法同时对这个表进行修改操作，即使它们要修改的是表中的不同记录。表锁的粒度比较粗，会限制其他事务对整个表的访问。

2. 行级锁（Row-level Locks）：行级锁是针对数据表中的每一行记录进行锁定，当一个事务获取了对某一行记录的行级锁后，其他事务还可以同时对表中的其他行进行读取或修改操作。行级锁的粒度更细，能够更好地支持并发访问。

<font color=#99CCFF style=" font-weight:bold;">在InnoDB引擎中，默认情况下使用的是行级锁来实现并发控制</font>。行级锁可以最大程度地提高并发性能，减少锁冲突和阻塞情况。而表锁通常在特定场景下使用，如需要快速锁定整个表进行操作时，或者为了避免某些特定的并发问题而需要手动选择表锁。

总的来说，行级锁提供了更细粒度的并发控制，更适合常见的并发访问场景；而表锁虽然简单直接，但在大多数情况下不推荐使用，因为会降低数据库的并发性能和响应速度。

##### 死锁案例
**案例一 两个事务同时对一行进行增删改,并加排它锁**

用户A执行：
```sql
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE user_id = 123;
UPDATE products SET stock = stock + 1 WHERE product_id = 456;
COMMIT;
```

用户B执行：
```sql
BEGIN;
UPDATE products SET stock = stock - 1 WHERE product_id = 456;
UPDATE accounts SET balance = balance + 100 WHERE user_id = 123;
COMMIT;
```

在这个场景中，用户A先锁定了products表中product_id为456的行，然后尝试更新accounts表；而用户B则先锁定了accounts表中user_id为123的行，然后尝试更新products表。由于两个事务的操作顺序不一致，很可能会导致死锁的发生。

<font color=#99CCFF style=" font-weight:bold;">行级锁相互锁定了,导致死锁</font>

**案列2 对select加额外升级锁后,两事务对同一行加锁**

用户A执行：
```sql
BEGIN;
SELECT * FROM orders WHERE user_id = 123 FOR UPDATE; -- 获取订单信息并加排他锁
UPDATE products SET stock = stock - 1 WHERE product_id = 456;
COMMIT;
```

用户B执行：
```sql
BEGIN;
SELECT * FROM products WHERE product_id = 456 FOR UPDATE; -- 获取产品信息并加排他锁
UPDATE orders SET status = 'shipped' WHERE order_id = 789;
COMMIT;
```

在这个例子中，用户A先获取了orders表中user_id为123的订单信息并加排他锁，然后尝试更新products表；而用户B则先获取了products表中product_id为456的产品信息并加排他锁，然后尝试更新orders表。这种交叉持有锁和操作不一致的情况容易导致死锁的发生。




为避免这种情况下的死锁，可以考虑以下解决方法：

1. 统一事务的操作顺序，确保所有事务都按照相同的顺序操作数据库表；
2. 减少事务中持有的锁数量和时间，尽量缩短事务的执行时间；
3. 在应用程序中使用尽量少的SQL语句来完成需要的操作；
4. 使用合适的索引和查询语句，减少数据访问的范围，降低发生死锁的概率；
5. 监控数据库系统，及时发现死锁并进行处理。


### sql执行过程

1. 连接管理：MySQL通过连接池管理数据库连接，当有客户端发送SQL请求时，会从连接池中获取一个可用的连接。

2. 语句分析和优化：MySQL接收到SQL请求后，首先会对SQL语句进行语法分析和语义分析，生成执行计划。优化器会根据查询条件、索引等情况选择最优的执行方案。

3. 锁管理：在执行SQL语句时，MySQL会根据具体的操作和事务隔离级别自动添加适当的锁来保证数据的一致性。不同的锁级别会影响并发访问的方式和性能。

4. 执行SQL语句：MySQL会执行经过优化的SQL语句，并返回结果给客户端。在执行过程中，会根据需要读取数据页、执行计划中的操作等。

5. 事务管理：对于涉及事务的SQL请求，MySQL会根据事务的开始、提交、回滚等操作来确保事务的原子性、一致性、隔离性和持久性。

6. 结果返回：执行完SQL语句后，MySQL将结果返回给客户端，并释放相应的资源，如锁、连接等。

在处理并发的SQL请求时，MySQL会根据事务隔离级别、锁机制、执行计划优化等因素来保证多个同时进行的操作之间不会相互干扰，确保数据操作的正确性和一致性。通过合理设置参数、索引、优化SQL语句等手段，可以提高MySQL处理并发请求的性能和效率。