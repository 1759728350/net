

#### 进程监控

```shell
ps -f ##查看主要运行的进程
ps -ef  ##查看所有进程,一般用grep过滤
```

ps代表"process status"，通过该命令可以列出系统中当前运行的进程信息。

以下是ps命令的常见选项和功能：

1. **显示当前用户的进程**：默认情况下，ps命令会显示当前用户的所有进程。
    
2. **显示所有用户的进程**：使用`ps -e`或`ps aux`可以显示所有用户的进程，而非仅限于当前用户。
    
3. **显示完整格式**：使用`ps -f`可以显示更加详细的进程信息，包括PID（进程ID）、PPID（父进程ID）、UID（用户ID）、CPU利用率、内存占用等。
    
4. **显示所有进程及线程**：通过`ps -eLf`可以显示系统中所有进程及其线程的信息。
    
5. **显示进程树状结构**：使用`ps -ejH`或`ps axjf`可以显示进程之间的父子关系，以树状结构展示进程间的关系。
    
6. **显示进程树和进程组ID**：通过`ps -ejH`可以显示进程树、PID以及PGID（进程组ID）的信息。
    
7. **按内存占用排序**：使用`ps aux --sort -rss`可以按照内存占用大小对进程进行排序。
    
8. **实时刷新进程信息**：使用`ps -aux`结合管道和`watch`命令可以实现实时刷新进程信息的效果。
    
9. **定时显示进程信息**：结合crontab和ps命令，可以定时监控并记录系统中的进程信息。


>正在执行的命令本身就是进程
```shell
[root@VM-4-10-centos ~]# bash 
[root@VM-4-10-centos ~]# sh
sh-4.2# ps -f
UID        PID  PPID  C STIME TTY          TIME CMD
root      9135 30099  0 09:05 pts/0    00:00:00 bash
root      9457  9135  0 09:05 pts/0    00:00:00 sh
root      9547  9457  0 09:05 pts/0    00:00:00 ps -f
root     30099 30090  0 08:56 pts/0    00:00:00 -bash

##先进入bash 再进入sh,就会看到这两个程序的进程
```

```shell
pstree    ##查看进程树
```

#### cpu内存监控top命令

查看当前所有进程的cpu,内存占用率
根据负载可以判断出cpu的使用率高,io出问题了
```shell
top
```

```shell
PID USER      PR  NI    VIRT    RES    SHR S  %CPU   %MEM     TIME+ COMMAND                                                                                                                                   
 9033 root      20   0 1022676  83724  13616 S   2.3  4.1 447:45.41 YDService                                                                                                                                 
23666 root      20   0  757320  17464   2624 S   1.0  0.9 453:12.50 barad_agent                                                                                                                               
 9    root      20   0       0      0      0 S   0.3  0.0 138:49.19 rcu_sched  
```

1. **PID（Process ID）**：进程ID，标识每个进程的唯一数字。
   
3. **PR（Priority）**：进程优先级。
   
4. **NI（Nice value）**：进程的优先级值，负值表示高优先级，正值表示低优先级。
   
5. **VIRT（Virtual Memory）**：进程使用的虚拟内存量。
   
6. **RES（Resident Memory）**：进程实际使用的物理内存量。
   
7. **SHR（Shared Memory）**：进程使用的共享内存量。
   
8. **%CPU**：进程占用CPU的百分比。
   
9. **%MEM**：进程占用内存的百分比。
   
10. **TIME+**：进程已经执行的CPU时间。
    
11. **COMMAND**：启动进程的命令名称。

## netstat查看网络连接状态

>用户可以查看当前系统的网络连接情况，包括TCP连接、UDP连接、监听状态、数据包统计等，帮助分析网络问题并进行故障排除。
```shell
netstat -tulpn
```

1. **netstat -a**：显示所有活动的网络连接和监听端口。
2. **netstat -t**：显示所有TCP协议相关的网络连接。
3. **netstat -u**：显示所有UDP协议相关的网络连接。
4. **netstat -n**：以数字形式显示地址和端口号，而不解析为域名或服务名。
5. **netstat -p**：显示与连接相关的进程ID（PID）和进程名称。
6. **netstat -r**：显示系统的路由表。
7. **netstat -s**：显示网络统计信息，如传输数据包的数量、错误等。
8. **netstat -i**：显示网络接口的信息，如收发数据包的统计信息和错误信息

**netstat -tulpn**：这个命令选项会列出所有TCP和UDP协议的网络连接信息，包括IP地址、端口号以及对应的进程ID（PID）。其中，"-t"表示只显示TCP协议相关信息，"-u"表示只显示UDP协议相关信息，"-p"表示显示进程名或PID，"-n"表示以数字形式显示地址和端口号而不解析为域名或服务名。
"l"选项，表示只显示监听中的连接。

```shell
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    
tcp        0      0 0.0.0.0:6379            0.0.0.0:*               LISTEN      8932/docker-proxy   
tcp        0      0 0.0.0.0:8080            0.0.0.0:*               LISTEN      24041/docker-proxy  
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1374/sshd           
tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN      1307/master         
tcp6       0      0 :::6379                 :::*                    LISTEN      8938/docker-proxy   
tcp6       0      0 :::8080                 :::*                    LISTEN      24047/docker-proxy  
```

##### 检查端口是否被监听来判断服务有没有被启动


当服务器出现网络连接问题时，可以使用netstat命令结合其他工具进行具体的故障排除。下面是一个示例：

假设服务器上某个服务无法被外部访问，可能是因为服务未正确启动或者监听的端口有问题。

1. 首先使用netstat命令查看服务器上所有的网络连接状态：

```bash
netstat -tuln
```

2. 确保服务已经启动并在监听指定的端口，比如我们要排查80端口（HTTP服务）的情况：

```bash
netstat -tuln | grep :80
```

3. 如果发现80端口没有处于监听状态，可能是服务未正确启动。可以尝试重启相关的服务：

```bash
sudo systemctl restart apache2   # 以Apache HTTP服务器为例
```

4. 再次使用netstat命令检查端口是否处于监听状态，确认服务已正确启动：

```bash
netstat -tuln | grep :80
```


##### 特定ip无法访问服务器被防火墙拦截

当服务器出现网络连接问题时，还可以使用netstat命令结合其他工具进行故障排除。下面是另一个示例：

假设服务器上某个特定IP无法访问，可能是因为防火墙设置或网络配置问题。

1. 首先使用netstat命令查看服务器上所有的网络连接状态：

```bash
netstat -tuln
```

2. 检查目标IP是否建立了连接，比如要检查与IP地址为192.168.1.100的主机的连接：

```bash
netstat -ant | grep 192.168.1.100
```

3. 如果没有建立连接，可能是防火墙阻止了该IP地址的访问。可以检查防火墙规则是否允许该IP地址通过：

```bash
sudo iptables -L | grep 192.168.1.100
```

4. 如果发现防火墙规则中未包含该IP，可以尝试添加允许该IP的规则：

```bash
sudo iptables -A INPUT -s 192.168.1.100 -j ACCEPT
```

5. 重新检查连接状态，确保目标IP可以正常访问：

```bash
netstat -ant | grep 192.168.1.100
```

通过以上步骤，结合netstat命令和防火墙规则检查，可以帮助排除特定IP无法访问的问题，并适时更新防火墙规则以恢复连接。



##### 特定ip造成过高负载
当服务器出现网络连接问题时，还可以使用netstat命令结合其他工具进行故障排除。

假设服务器上的某个服务响应缓慢，可能是因为存在大量的连接导致服务负载过高。

1. 使用netstat命令查看当前连接数情况，以及各个状态的连接数量：

```bash
netstat -ant | awk '{print $6}' | sort | uniq -c
```

这条命令会列出各种连接状态的数量，包括ESTABLISHED（已建立连接）、TIME_WAIT（等待关闭连接）等。

2. 检查是否有大量连接处于ESTABLISHED状态，如果发现有大量连接积压，可能是服务负载过高。
    
3. 可以使用以下命令查看建立连接最多的IP地址：
    

```bash
netstat -ntu | awk '{print $5}' | cut -d: -f1 | sort | uniq -c | sort -nr | head
```

这条命令将列出建立连接最多的IP地址及其连接数，可以帮助确定哪些IP地址导致了连接积压。

4. 根据具体情况，可以考虑限制某些IP地址的连接数或者优化服务端配置来减轻负载压力，从而提高服务响应速度。

通过以上步骤，结合netstat命令和连接状态检查，可以帮助定位服务响应缓慢的问题，并采取相应措施优化服务性能。

##### 检查是否端口占用服务未启动
假设服务器上某个特定端口无法建立连接，可能是因为端口被占用或者服务未正确启动。

1. 使用netstat命令查看服务器上所有的网络连接状态，并筛选出要排查的端口（例如8080）:

```bash
netstat -tuln | grep :8080
```

2. 如果发现端口未处于监听状态，可能是服务未正确启动或者端口被其他程序占用。尝试查看占用该端口的进程信息：

```bash
lsof -i :8080
```

3. 根据lsof命令的输出，确定哪个进程在占用该端口，可以选择关闭该进程或者修改服务配置来使用其他端口。
    
4. 若端口被占用的情况排除，可尝试重启相关服务并再次检查端口状态：
    

```bash
sudo systemctl restart your_service_name   # 重启对应的服务
netstat -tuln | grep :8080
```

5. 确保端口正确监听，然后尝试重新建立连接，验证问题是否解决。


##### TIME_WAIT状态的连接过多网络负载大


1. 使用netstat命令查看服务器上所有的网络连接状态，并检查当前服务器的TCP连接数情况：

```bash
netstat -atn | awk '{print $6}' | sort | uniq -c
```

2. 如果发现大量的TIME_WAIT状态的连接，可能导致网络负载过高，需要进一步排查。
    
3. 使用sysctl工具调整TCP参数，减少TIME_WAIT连接的等待时间，从而降低网络负载：
    

```bash
sudo sysctl -w net.ipv4.tcp_tw_reuse=1
```

4. 重启网络服务以使参数设置生效：

```bash
sudo systemctl restart networking
```

5. 再次使用netstat命令监控网络连接状态，观察TIME_WAIT连接数量是否减少，网络负载是否有所改善。


## ifconfig配置网络接口信息
`ifconfig`（interface configuration）主要用于配置和显示网络接口的信息


#### 调整MTU优化丢包
一个常见的网络性能调优例子是调整网络接口的MTU（最大传输单元）大小。MTU指的是一次数据包在网络上传输的最大尺寸，通常以字节为单位。
如果网络接口的MTU设置过小，会导致数据包需要被分片传输，增加网络开销和延迟；
而如果MTU设置过大，可能会导致数据包在传输过程中被丢弃或造成网络拥塞。

通过netstat命令查看网络接口的统计信息，我们可以了解当前网络接口的数据传输情况，包括是否有数据包被分片、丢包率等。如果发现网络性能不佳，可以考虑调整网络接口的MTU大小来优化网络性能。

假设我们通过netstat命令发现网络接口eth0存在较高的丢包率，我们可以通过以下步骤来调整网络接口eth0的MTU大小：

1. 首先，使用ifconfig命令查看当前网络接口eth0的MTU大小：

```bash
ifconfig eth0
```

2. 然后，使用ifconfig命令来修改网络接口eth0的MTU大小，例如将MTU设置为1500：

```bash
sudo ifconfig eth0 mtu 1500
```

3. 最后，再次使用netstat命令观察网络接口eth0的统计信息，查看是否丢包率有所改善。

通过调整网络接口的MTU大小，我们可以优化网络性能，减少数据包分片和丢包，提高数据传输效率。

##### MTU大小问题
MTU（Maximum Transmission Unit）的大小确实会影响网络数据包传输过程中是否会发生分片和丢包的情况。一般来说，MTU越大，数据包传输的效率可能会更高，但同时也增加了数据包被分片和丢包的风险。以下是关于MTU大小对丢包的影响的一些考虑：

1. **MTU大小与分片**：当要发送的数据包大小超过目标网络的MTU值时，会触发IP层的分片过程，将大的数据包分割成多个较小的数据包进行传输。这种分片过程会增加数据包在传输过程中被丢失的风险，因为一个分片数据包丢失会导致整个数据包无法完整传输。
    
2. **MTU大小与丢包**：较大的MTU值意味着单个数据包的大小可能更大，从而使得每个数据包在传输过程中受到噪声、拥塞或其他问题的影响的概率也更大。如果网络中有拥塞、丢包或其他问题，较大的数据包可能更容易受到干扰而丢失。
    
3. **MTU大小选择**：在选择MTU大小时，需要综合考虑网络设备、网络传输介质以及网络负载等因素。较大的MTU值可以提高传输效率，减少CPU开销和网络延迟；但同时也需要考虑网络稳定性和可靠性，避免过大的MTU值引起频繁的数据丢失。