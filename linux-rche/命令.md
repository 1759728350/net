## linux系统特点

#### 文件分布

一个软件的文件分布在各个文件夹中

有python目录可以得出

```shell
whereis $(readlink -f $(which python))
python2: /usr/bin/python2 /usr/bin/python2.7-config /usr/bin/python2.7 /usr/lib/python2.7 /usr/lib64/python2.7 /usr/include/python2.7 /usr/share/man/man1/python2.1.gz
```

意味着在您的系统中，`python2`命令的相关文件可以在以下位置找到：

- `/usr/bin/python2`: `python2`的可执行文件路径
- `/usr/bin/python2.7-config`: `python2.7-config`的可执行文件路径
- `/usr/bin/python2.7`: `python2.7`的可执行文件路径
- `/usr/lib/python2.7`: `python2.7`的库文件路径
- `/usr/lib64/python2.7`: `python2.7`的64位版本库文件路径
- `/usr/include/python2.7`: `python2.7`的头文件路径
- `/usr/share/man/man1/python2.1.gz`: `python2`的手册页路径

#### 常用目录特点

是的，这在Linux系统中很常见。一个软件通常由多个组件或文件组成，它们可能包括可执行文件、配置文件、库文件、头文件、文档等。为了组织和管理这些文件，它们被放置在系统中不同的目录中。

在Linux中，常见的目录结构如下：

- `/bin`: 存放系统的基本命令，可以直接在命令行中执行的可执行文件。
- `/sbin`: 存放系统管理员使用的命令，一般需要超级用户权限才能执行的可执行文件。
- `/usr/bin`: 存放用户安装的软件的可执行文件。
- `/usr/sbin`: 存放用户安装的软件的管理员命令的可执行文件。
- `/lib`: 存放系统所需的共享库文件。
- `/usr/lib`: 存放用户安装的软件所需的共享库文件。
- `/include`: 存放C/C++头文件。
- `/usr/include`: 存放用户安装的软件所需的C/C++头文件。
- `/usr/share/man`: 存放命令的手册页。
- `/etc`: 存放系统的配置文件。
- `/var`: 存放变量数据，例如日志文件、缓存文件等。

每个目录都有其特定的用途，通过将软件的不同组件放置在合适的目录中，可以更好地管理和组织软件文件，并使系统能够正确地找到和使用这些文件。



# linux基本命令

linux中的所有命令相当于可执行文件,你可以这样理解:在linux中软件,二进制可执行文件,一行命令

这些都是软件,只不过由于windows这个图形化操作系统让我们误认为有界面的才是软件,其实一个命令也好,一个可执行程

序也好,都是软件

#### pwd

```shell
pwd   ##print work directory打印当前目录路径
```

#### 路径规则

以/开头就是以根路径作为锚点

不以/开头就是以当前路径作为锚点 进行路径查找

```shell
./当前路径为锚点 ##take the current path as the source point |  take .. as把..当做   
../从上一路径为锚点## take the previous path as the source point

find ./ -name a.txt  ##find a.txt from the current directory
```



#### touch命令

touch意味触摸的意思,更改一个已存在文件并更新其时间戳,如果文件不存在则创建文件

摸过一次就会创建时间戳

#### find命令

```shell
find 路径 -name 文件名
##文件名可以用通配符

##从usr/lib路径下寻找以test结尾的文件
find /usr/lib -name *test

*表示空或任意多个的任意符号所以很好用
*aaa:以aaa结尾的文件
aaa*:以aaa为头的文件
*aaa*:文件名包含aaa的文件
```



#### ls命令及文件种类特点

来查看文件或目录的类型。`ls`命令以列表的形式显示文件和目录，并使用不同的标识符来表示它们的类型。以下是一些常见的文件类型标识符：

- `-` 表示普通文件。
- `d` 表示目录。
- `l` 表示符号链接（Symbolic Link）。
- `c` 表示字符设备文件。
- `b` 表示块设备文件。
- `s` 表示套接字（socket）文件。
- `p` 表示命名管道（named pipe）文件。

#### vim

* 命令行模式

按esc进入命令行模式,该模式可以通过按键代替鼠标移动光标,进行移动光标操作

命令行模式的快捷按键:

hjkl移动光标  0移到行首 shift+4移动到行尾

/查找,光标到下面时输入你要找的值,和ctrl+f一个效果     

然后n是跳到下一个结果,shift+n跳到上一个匹配成功的结果

* 插入模式

i和一些其他键,进入写入模式

* 终结模式

按:   进入然后参数w保存,参数q退出



其他命令行模式命令

d删除

u相当于ctrl+z

r相当于ctrl+y反向撤销,和ctrl+z相反

gg跳到第一行,shift+g跳到最后一行

v选择块,然后移动光标

y复制,p粘贴

#### grep命令

查找过滤一个文件/文本含有对应匹配条件的内容

当我们对一批文件进行了操作但只想显示目的文件,我们就可以在命令后面加管道符| grep

#### 管道符

管道符会将前面的终端输出视作一个文本文件

管道后面的命令会将这个终端输出的所有字符当做一个文件去使用

#### 命令解析符

管道符的逆向,一些无法读取标准输入(控制台输入的文字)的命令想用另外一个命令的结果当做参数

此时就得用

```shell
readlink -f $(which python)
``也可以代替$()
##which命令   输出某个命令的可执行文件的地址,只包含可执行文件的地址
## 与之相比
##whereis命令 输出某个命令相关的所有文件路径,包括源代码,可执行文件,手册

whereis $(readlink -f $(which python))
python2: /usr/bin/python2 /usr/bin/python2.7-config /usr/bin/python2.7 /usr/lib/python2.7 /usr/lib64/python2.7 /usr/include/python2.7 /usr/share/man/man1/python2.1.gz 
##因为python本身是环境变量,所以which python获得python这个命令的路径
##发现这个路径是软连接,所以用readlink -f来递归找到其文件路径
lrwxrwxrwx  1 root root           7 3月  23 2023 python -> python2
lrwxrwxrwx  1 root root           9 3月  23 2023 python2 -> python2.7
-rwxr-xr-x  1 root root        7144 6月  28 2022 python2.7
##一路递归最终找到python这个软连接指向的python2.7  -rwxr说明这是个文件,l开头表示软连接
##whereis python2.7就能获取该文件的相关所有源代码,可执行文件,手册
```





#### wc命令

统计文件,文本的行数,字节数,单词数

#### 终端输出重定向符

```shell
> 一个是覆盖到对应文件
>> 两个表示追加到文件

ll -a -l > b.txt
```

echo命令可以将字符串输出到终端,也就是说echo可以将一个字符串转化为一个文件单位

而重定向符号和管道都可以利用终端上的内容

```shell
echo hello >> ./testdir/b.txt
```

#### tail命令

输出文件最后几行 

```shell
tail -5 -f a.txt  ##-f means to follow,to listen for the changes to this file

tail -3 c.txt| tail -1  ##take the last third line as the text and read the last line
```



#### 终止快捷键

ctrl+c终止当前终端的程序执行

ctrl+d退出当前应用的命令行,回到终端





# docker

#### docker命令

不同应用比如mysql,redis运行需要的各种依赖的库以及各种不同的配置参数,如果库版本不同会产生不兼容,所以每个容器中的应用都把依赖打包隔离不相互影响

不同操作系统,a程序依赖的系统函数的是centos,b程序依赖的系统函数用的是ubuntu,docker容器能把其所需要的操作系统函数也一起打包的容器中

#### docker server

docker分为client和server

client主要用来发命令

server主要处理发来的命令,比如docker build将一些应用和配置文件进行打包为一个镜像,然后我们可以将这个镜像推送到类似github叫dockerhub,以后方便直接拉取对应的配置的镜像

当我们拉取完镜像到docker server,我们可以在docker client上用docker run命令将镜像跑起来

一个镜像跑起来就会生成多个容器,容器就是镜像跑起来后生成的进程

容器跑起来后,不会对镜像进行写操作,比如一些镜像内部需要产生一些data数据和log数据,容器并不会将这些数据写到镜像里,而是将这些数据保存到容器本身中

##### dockerfile

根据dockerfile生成镜像,此时使用docker build

或者用一个压缩包来解压出一个镜像,用docker load,当然也可以逆向将镜像打包

第三种获取镜像的方式就是从类似hub的远程镜像服务器拉取,使用docker 



### linux网络管理

#### ping命令

```shell
ping www.baidu.com 
```

可以看网络对应两个linux的端口通不通

可以设置ping时发几个数据包,每个数据包间隔多久,也可以做压力测试,不停发数据包

发送的时候是发送icmp协议数据包,会有成功返回的信息

该信息包含最大返回时间,最小方差抖动时间以及接收了几个包,发送了几个包来分析丢包率

当然你也可以设置一个icmp包的大小,太大了对面服务器防火墙也会给你拦下来



# rche考试题







下班了吗?

哦下了下了,刚下班

* 您上班也累啊,患者不停的,忙的时候可能连喝水都没时间

偶尔,不会那么忙

* 多注意休息休息,别累坏了

不算累,谢谢哦



* 国庆患者还是很多吧

  

* 现在咱们这代压力都还是不小的
* 我感觉我那个专业有一堆学不完的东西
* 医学坑定学得更多

学得确实多

* 你牙科也学哪些临床要学的科目吗

是的





